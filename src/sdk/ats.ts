/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
    encodeDeepObjectQuery as encodeDeepObjectQuery$,
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
    queryJoin as queryJoin$,
} from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import { unwrap as unwrap$ } from "./types/fp.js";

export class Ats extends ClientSDK {
    /**
     * Create Application
     */
    async createApplication(
        request: operations.AtsCreateApplicationRequest,
        options?: RequestOptions
    ): Promise<operations.AtsCreateApplicationResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsCreateApplicationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.AtsCreateApplicationRequestDto, {
            explode: true,
        });

        const path$ = pathToFunc("/unified/ats/applications")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_create_application",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsCreateApplicationResponse,
            SDKError | SDKValidationError
        >(
            m$.json(201, operations.AtsCreateApplicationResponse$inboundSchema, {
                key: "CreateResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Create Candidate
     */
    async createCandidate(
        request: operations.AtsCreateCandidateRequest,
        options?: RequestOptions
    ): Promise<operations.AtsCreateCandidateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsCreateCandidateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.AtsCreateCandidateRequestDto, { explode: true });

        const path$ = pathToFunc("/unified/ats/candidates")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_create_candidate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsCreateCandidateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsCreateCandidateResponse$inboundSchema, {
                key: "CreateResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Create Candidate Note
     */
    async createCandidateNote(
        request: operations.AtsCreateCandidateNoteRequest,
        options?: RequestOptions
    ): Promise<operations.AtsCreateCandidateNoteResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsCreateCandidateNoteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.AtsCreateNotesRequestDto, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/candidates/{id}/notes")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_create_candidate_note",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsCreateCandidateNoteResponse,
            SDKError | SDKValidationError
        >(
            m$.json(201, operations.AtsCreateCandidateNoteResponse$inboundSchema, {
                key: "CreateResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Creates an offer
     */
    async createOffer(
        request: operations.AtsCreateOfferRequest,
        options?: RequestOptions
    ): Promise<operations.AtsCreateOfferResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsCreateOfferRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.AtsCreateOfferRequestDto, { explode: true });

        const path$ = pathToFunc("/unified/ats/offers")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_create_offer",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsCreateOfferResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsCreateOfferResponse$inboundSchema, { key: "CreateResult" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Download Application Document
     */
    async downloadApplicationDocument(
        request: operations.AtsDownloadApplicationDocumentRequest,
        options?: RequestOptions
    ): Promise<operations.AtsDownloadApplicationDocumentResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.AtsDownloadApplicationDocumentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            subResourceId: encodeSimple$("subResourceId", payload$.subResourceId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc(
            "/unified/ats/applications/{id}/documents/{subResourceId}/download"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            format: payload$.format,
        });

        const headers$ = new Headers({
            Accept: "application/octet-stream",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_download_application_document",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsDownloadApplicationDocumentResponse,
            SDKError | SDKValidationError
        >(
            m$.stream(200, operations.AtsDownloadApplicationDocumentResponse$inboundSchema, {
                key: "response-stream",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Application
     */
    async getApplication(
        request: operations.AtsGetApplicationRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetApplicationResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetApplicationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                expand: payload$.expand,
                fields: payload$.fields,
                include: payload$.include,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_application",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetApplicationResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetApplicationResponse$inboundSchema, {
                key: "ApplicationResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Application Document
     */
    async getApplicationDocument(
        request: operations.AtsGetApplicationDocumentRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetApplicationDocumentResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetApplicationDocumentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            subResourceId: encodeSimple$("subResourceId", payload$.subResourceId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/documents/{subResourceId}")(
            pathParams$
        );

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_application_document",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetApplicationDocumentResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetApplicationDocumentResponse$inboundSchema, {
                key: "AtsDocumentResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Application Offer
     */
    async getApplicationOffer(
        request: operations.AtsGetApplicationOfferRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetApplicationOfferResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetApplicationOfferRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            subResourceId: encodeSimple$("subResourceId", payload$.subResourceId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/offers/{subResourceId}")(
            pathParams$
        );

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_application_offer",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetApplicationOfferResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetApplicationOfferResponse$inboundSchema, {
                key: "OffersResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Applications scheduled interview
     */
    async getApplicationScheduledInterview(
        request: operations.AtsGetApplicationScheduledInterviewRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetApplicationScheduledInterviewResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.AtsGetApplicationScheduledInterviewRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            subResourceId: encodeSimple$("subResourceId", payload$.subResourceId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc(
            "/unified/ats/applications/{id}/scheduled_interviews/{subResourceId}"
        )(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_application_scheduled_interview",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetApplicationScheduledInterviewResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetApplicationScheduledInterviewResponse$inboundSchema, {
                key: "ScheduledInterviewsResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Application Scorecard
     */
    async getApplicationScorecard(
        request: operations.AtsGetApplicationScorecardRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetApplicationScorecardResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetApplicationScorecardRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            subResourceId: encodeSimple$("subResourceId", payload$.subResourceId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/scorecards/{subResourceId}")(
            pathParams$
        );

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_application_scorecard",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetApplicationScorecardResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetApplicationScorecardResponse$inboundSchema, {
                key: "ScorecardsResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Assessments Package
     */
    async getAssessmentsPackage(
        request: operations.AtsGetAssessmentsPackageRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetAssessmentsPackageResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetAssessmentsPackageRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/assessments/packages/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_assessments_package",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetAssessmentsPackageResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetAssessmentsPackageResponse$inboundSchema, {
                key: "AssessmentsPackagesResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Assessments Requests
     */
    async getAssessmentsRequest(
        request: operations.AtsGetAssessmentsRequestRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetAssessmentsRequestResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetAssessmentsRequestRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/assessments/orders/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_assessments_request",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetAssessmentsRequestResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetAssessmentsRequestResponse$inboundSchema, {
                key: "AssessmentsResultsResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Assessments Results
     */
    async getAssessmentsResult(
        request: operations.AtsGetAssessmentsResultRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetAssessmentsResultResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetAssessmentsResultRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/assessments/orders/{id}/results")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_assessments_result",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetAssessmentsResultResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetAssessmentsResultResponse$inboundSchema, {
                key: "AssessmentsResultsResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Candidate
     */
    async getCandidate(
        request: operations.AtsGetCandidateRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetCandidateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetCandidateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/candidates/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                include: payload$.include,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_candidate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetCandidateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetCandidateResponse$inboundSchema, {
                key: "CandidateResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Candidate Note
     */
    async getCandidateNote(
        request: operations.AtsGetCandidateNoteRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetCandidateNoteResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetCandidateNoteRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
            subResourceId: encodeSimple$("subResourceId", payload$.subResourceId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/unified/ats/candidates/{id}/notes/{subResourceId}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_candidate_note",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetCandidateNoteResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetCandidateNoteResponse$inboundSchema, {
                key: "NoteResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Department
     */
    async getDepartment(
        request: operations.AtsGetDepartmentRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetDepartmentResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetDepartmentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/departments/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_department",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetDepartmentResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetDepartmentResponse$inboundSchema, {
                key: "DepartmentResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Interview
     */
    async getInterview(
        request: operations.AtsGetInterviewRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetInterviewResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetInterviewRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/interviews/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_interview",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetInterviewResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetInterviewResponse$inboundSchema, {
                key: "InterviewsResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Interview Stage
     */
    async getInterviewStage(
        request: operations.AtsGetInterviewStageRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetInterviewStageResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetInterviewStageRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/interview_stages/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_interview_stage",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetInterviewStageResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetInterviewStageResponse$inboundSchema, {
                key: "InterviewStageResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Job
     */
    async getJob(
        request: operations.AtsGetJobRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetJobResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetJobRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/jobs/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                expand: payload$.expand,
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_job",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetJobResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetJobResponse$inboundSchema, { key: "JobResult" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Job Posting
     */
    async getJobPosting(
        request: operations.AtsGetJobPostingRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetJobPostingResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetJobPostingRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/job_postings/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                include: payload$.include,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_job_posting",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetJobPostingResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetJobPostingResponse$inboundSchema, {
                key: "JobPostingResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get List
     */
    async getList(
        request: operations.AtsGetListRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetListResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetListRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/lists/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_list",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetListResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetListResponse$inboundSchema, { key: "ListResult" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Location
     */
    async getLocation(
        request: operations.AtsGetLocationRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetLocationResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetLocationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/locations/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_location",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetLocationResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetLocationResponse$inboundSchema, {
                key: "ATSLocationResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Offer
     */
    async getOffer(
        request: operations.AtsGetOfferRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetOfferResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetOfferRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/offers/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_offer",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetOfferResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetOfferResponse$inboundSchema, { key: "OffersResult" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get Rejected Reason
     */
    async getRejectedReason(
        request: operations.AtsGetRejectedReasonRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetRejectedReasonResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetRejectedReasonRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/rejected_reasons/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_rejected_reason",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetRejectedReasonResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetRejectedReasonResponse$inboundSchema, {
                key: "RejectedReasonResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get User
     */
    async getUser(
        request: operations.AtsGetUserRequest,
        options?: RequestOptions
    ): Promise<operations.AtsGetUserResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsGetUserRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/users/{id}")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                raw: payload$.raw,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_get_user",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsGetUserResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsGetUserResponse$inboundSchema, { key: "UserResult" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List application custom field definitions
     */
    async listApplicationCustomFieldDefinitions(
        request: operations.AtsListApplicationCustomFieldDefinitionsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListApplicationCustomFieldDefinitionsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.AtsListApplicationCustomFieldDefinitionsRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/custom_field_definitions/applications")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_application_custom_field_definitions",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListApplicationCustomFieldDefinitionsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.AtsListApplicationCustomFieldDefinitionsResponse$inboundSchema,
                { key: "CustomFieldDefinitionsPaginated" }
            ),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Application Documents
     */
    async listApplicationDocuments(
        request: operations.AtsListApplicationDocumentsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListApplicationDocumentsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListApplicationDocumentsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/documents")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_application_documents",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListApplicationDocumentsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListApplicationDocumentsResponse$inboundSchema, {
                key: "AtsDocumentsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Application Scorecards
     */
    async listApplicationScorecards(
        request: operations.AtsListApplicationScorecardsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListApplicationScorecardsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListApplicationScorecardsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/scorecards")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_application_scorecards",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListApplicationScorecardsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListApplicationScorecardsResponse$inboundSchema, {
                key: "ScorecardsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Applications
     */
    async listApplications(
        request: operations.AtsListApplicationsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListApplicationsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListApplicationsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/applications")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                expand: payload$.expand,
                fields: payload$.fields,
                include: payload$.include,
                job_id: payload$.job_id,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_applications",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListApplicationsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListApplicationsResponse$inboundSchema, {
                key: "ApplicationsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Application Offers
     */
    async listApplicationsOffers(
        request: operations.AtsListApplicationsOffersRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListApplicationsOffersResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListApplicationsOffersRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/offers")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_applications_offers",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListApplicationsOffersResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListApplicationsOffersResponse$inboundSchema, {
                key: "OffersPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Applications scheduled interviews
     */
    async listApplicationsScheduledInterviews(
        request: operations.AtsListApplicationsScheduledInterviewsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListApplicationsScheduledInterviewsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.AtsListApplicationsScheduledInterviewsRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/scheduled_interviews")(
            pathParams$
        );

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_applications_scheduled_interviews",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListApplicationsScheduledInterviewsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListApplicationsScheduledInterviewsResponse$inboundSchema, {
                key: "ScheduledInterviewsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Assessments Packages
     */
    async listAssessmentsPackages(
        request: operations.AtsListAssessmentsPackagesRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListAssessmentsPackagesResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListAssessmentsPackagesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/assessments/packages")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_assessments_packages",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListAssessmentsPackagesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListAssessmentsPackagesResponse$inboundSchema, {
                key: "AssessmentsPackagesPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List candidate custom field definitions
     */
    async listCandidateCustomFieldDefinitions(
        request: operations.AtsListCandidateCustomFieldDefinitionsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListCandidateCustomFieldDefinitionsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.AtsListCandidateCustomFieldDefinitionsRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/custom_field_definitions/candidates")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_candidate_custom_field_definitions",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListCandidateCustomFieldDefinitionsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListCandidateCustomFieldDefinitionsResponse$inboundSchema, {
                key: "CustomFieldDefinitionsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Candidate Notes
     */
    async listCandidateNotes(
        request: operations.AtsListCandidateNotesRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListCandidateNotesResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListCandidateNotesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/candidates/{id}/notes")(pathParams$);

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_candidate_notes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListCandidateNotesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListCandidateNotesResponse$inboundSchema, {
                key: "NotesPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Candidates
     */
    async listCandidates(
        request: operations.AtsListCandidatesRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListCandidatesResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListCandidatesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/candidates")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                include: payload$.include,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_candidates",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListCandidatesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListCandidatesResponse$inboundSchema, {
                key: "CandidatesPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Departments
     */
    async listDepartments(
        request: operations.AtsListDepartmentsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListDepartmentsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListDepartmentsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/departments")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_departments",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListDepartmentsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListDepartmentsResponse$inboundSchema, {
                key: "DepartmentsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Interview Stages
     */
    async listInterviewStages(
        request: operations.AtsListInterviewStagesRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListInterviewStagesResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListInterviewStagesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/interview_stages")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_interview_stages",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListInterviewStagesResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListInterviewStagesResponse$inboundSchema, {
                key: "InterviewStagesPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Interviews
     */
    async listInterviews(
        request: operations.AtsListInterviewsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListInterviewsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListInterviewsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/interviews")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_interviews",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListInterviewsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListInterviewsResponse$inboundSchema, {
                key: "InterviewsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Job Postings
     */
    async listJobPostings(
        request: operations.AtsListJobPostingsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListJobPostingsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListJobPostingsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/job_postings")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                include: payload$.include,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_job_postings",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListJobPostingsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListJobPostingsResponse$inboundSchema, {
                key: "JobPostingsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Jobs
     */
    async listJobs(
        request: operations.AtsListJobsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListJobsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListJobsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/jobs")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                expand: payload$.expand,
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_jobs",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListJobsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListJobsResponse$inboundSchema, { key: "JobsPaginated" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Get all Lists
     */
    async listLists(
        request: operations.AtsListListsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListListsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListListsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/lists")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_lists",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListListsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListListsResponse$inboundSchema, { key: "ListsPaginated" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List locations
     */
    async listLocations(
        request: operations.AtsListLocationsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListLocationsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListLocationsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/locations")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_locations",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListLocationsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListLocationsResponse$inboundSchema, {
                key: "ATSLocationsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Offers
     */
    async listOffers(
        request: operations.AtsListOffersRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListOffersResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListOffersRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/offers")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_offers",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListOffersResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListOffersResponse$inboundSchema, {
                key: "OffersPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Rejected Reasons
     */
    async listRejectedReasons(
        request: operations.AtsListRejectedReasonsRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListRejectedReasonsResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListRejectedReasonsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/rejected_reasons")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_rejected_reasons",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListRejectedReasonsResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListRejectedReasonsResponse$inboundSchema, {
                key: "RejectedReasonsPaginated",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * List Users
     */
    async listUsers(
        request: operations.AtsListUsersRequest,
        options?: RequestOptions
    ): Promise<operations.AtsListUsersResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsListUsersRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/unified/ats/users")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                filter: payload$.filter,
                proxy: payload$.proxy,
            }),
            encodeFormQuery$({
                fields: payload$.fields,
                next: payload$.next,
                page: payload$.page,
                page_size: payload$.page_size,
                raw: payload$.raw,
                sync_token: payload$.sync_token,
                updated_after: payload$.updated_after,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_list_users",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsListUsersResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsListUsersResponse$inboundSchema, { key: "UsersPaginated" }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Update an Application
     */
    async updateApplication(
        request: operations.AtsUpdateApplicationRequest,
        options?: RequestOptions
    ): Promise<operations.AtsUpdateApplicationResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsUpdateApplicationRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.AtsUpdateApplicationRequestDto, {
            explode: true,
        });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_update_application",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsUpdateApplicationResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsUpdateApplicationResponse$inboundSchema, {
                key: "UpdateResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Update Candidate
     */
    async updateCandidate(
        request: operations.AtsUpdateCandidateRequest,
        options?: RequestOptions
    ): Promise<operations.AtsUpdateCandidateResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsUpdateCandidateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.AtsUpdateCandidateRequestDto, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/candidates/{id}")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_update_candidate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsUpdateCandidateResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsUpdateCandidateResponse$inboundSchema, {
                key: "CreateResult",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    /**
     * Upload Application Document
     */
    async uploadApplicationDocument(
        request: operations.AtsUploadApplicationDocumentRequest,
        options?: RequestOptions
    ): Promise<operations.AtsUploadApplicationDocumentResponse> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.AtsUploadApplicationDocumentRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.UnifiedUploadRequestDto, { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = pathToFunc("/unified/ats/applications/{id}/documents/upload")(pathParams$);

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-account-id": encodeSimple$("x-account-id", payload$["x-account-id"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ats_upload_application_document",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["400", "403", "412", "429", "4XX", "500", "501", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await m$.match<
            operations.AtsUploadApplicationDocumentResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.AtsUploadApplicationDocumentResponse$inboundSchema, {
                key: "WriteResultApiModel",
            }),
            m$.fail([400, 403, 412, 429, "4XX", 500, 501, "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }
}
