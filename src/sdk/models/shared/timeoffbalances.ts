/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { catchUnrecognizedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { Reason, Reason$inboundSchema } from "./reason.js";

export type TimeOffBalances4 = {};

export type TimeOffBalancesSourceValue =
  | string
  | number
  | boolean
  | TimeOffBalances4
  | Array<any>;

/**
 * The unified value for the duration unit. If the provider does not specify this unit, the value will be set to unknown
 */
export enum TimeOffBalancesValue {
  Minutes = "minutes",
  Hours = "hours",
  Days = "days",
  Weeks = "weeks",
  Months = "months",
  Years = "years",
  Unknown = "unknown",
  UnmappedValue = "unmapped_value",
}
/**
 * The unified value for the duration unit. If the provider does not specify this unit, the value will be set to unknown
 */
export type TimeOffBalancesValueOpen = OpenEnum<typeof TimeOffBalancesValue>;

/**
 * The duration unit of the current balance
 */
export type BalanceUnit = {
  sourceValue?:
    | string
    | number
    | boolean
    | TimeOffBalances4
    | Array<any>
    | null
    | undefined;
  /**
   * The unified value for the duration unit. If the provider does not specify this unit, the value will be set to unknown
   */
  value?: TimeOffBalancesValueOpen | null | undefined;
};

export enum TimeOffBalances2 {
  True = "true",
  False = "false",
}

/**
 * Indicates if this time off balance represents unlimited leave
 */
export type IsUnlimited = boolean | TimeOffBalances2;

export type TimeOffBalancesSchemas4 = {};

export type TimeOffBalancesSchemasSourceValue =
  | string
  | number
  | boolean
  | TimeOffBalancesSchemas4
  | Array<any>;

/**
 * The unified value for the duration unit. If the provider does not specify this unit, the value will be set to unknown
 */
export enum TimeOffBalancesSchemasValue {
  Minutes = "minutes",
  Hours = "hours",
  Days = "days",
  Weeks = "weeks",
  Months = "months",
  Years = "years",
  Unknown = "unknown",
  UnmappedValue = "unmapped_value",
}
/**
 * The unified value for the duration unit. If the provider does not specify this unit, the value will be set to unknown
 */
export type TimeOffBalancesSchemasValueOpen = OpenEnum<
  typeof TimeOffBalancesSchemasValue
>;

/**
 * The duration unit of the current policy
 */
export type TimeOffBalancesDurationUnit = {
  sourceValue?:
    | string
    | number
    | boolean
    | TimeOffBalancesSchemas4
    | Array<any>
    | null
    | undefined;
  /**
   * The unified value for the duration unit. If the provider does not specify this unit, the value will be set to unknown
   */
  value?: TimeOffBalancesSchemasValueOpen | null | undefined;
};

export type TimeOffBalancesSchemasPolicy4 = {};

export type TimeOffBalancesSchemasPolicySourceValue =
  | string
  | number
  | boolean
  | TimeOffBalancesSchemasPolicy4
  | Array<any>;

/**
 * The unified value for the type of the time off policy. If the provider does not specify this unit, the value will be set to unmapped_value
 */
export enum TimeOffBalancesSchemasPolicyValue {
  Sick = "sick",
  UnmappedValue = "unmapped_value",
  Vacation = "vacation",
  LongTermDisability = "long_term_disability",
  ShortTermDisability = "short_term_disability",
  Absent = "absent",
  CompTime = "comp_time",
  Training = "training",
  AnnualLeave = "annual_leave",
  LeaveOfAbsence = "leave_of_absence",
  Break = "break",
  ChildCareLeave = "child_care_leave",
  MaternityLeave = "maternity_leave",
  JuryDuty = "jury_duty",
  Sabbatical = "sabbatical",
  Accident = "accident",
  Paid = "paid",
  Unpaid = "unpaid",
  Holiday = "holiday",
  Personal = "personal",
  InLieu = "in_lieu",
  Bereavement = "bereavement",
  Other = "other",
}
/**
 * The unified value for the type of the time off policy. If the provider does not specify this unit, the value will be set to unmapped_value
 */
export type TimeOffBalancesSchemasPolicyValueOpen = OpenEnum<
  typeof TimeOffBalancesSchemasPolicyValue
>;

/**
 * The type of this policy
 */
export type TimeOffBalancesType = {
  sourceValue?:
    | string
    | number
    | boolean
    | TimeOffBalancesSchemasPolicy4
    | Array<any>
    | null
    | undefined;
  /**
   * The unified value for the type of the time off policy. If the provider does not specify this unit, the value will be set to unmapped_value
   */
  value?: TimeOffBalancesSchemasPolicyValueOpen | null | undefined;
};

/**
 * The time off policy associated with this balance
 */
export type TimeOffBalancesPolicy = {
  /**
   * The created_at date of this policy
   */
  createdAt?: Date | null | undefined;
  /**
   * The description of this policy
   */
  description?: string | null | undefined;
  /**
   * The duration unit of the current policy
   */
  durationUnit?: TimeOffBalancesDurationUnit | null | undefined;
  /**
   * Unique identifier
   */
  id?: string | null | undefined;
  /**
   * The name of this policy
   */
  name?: string | null | undefined;
  reasons?: Array<Reason> | null | undefined;
  /**
   * Provider's unique identifier
   */
  remoteId?: string | null | undefined;
  /**
   * The type of this policy
   */
  type?: TimeOffBalancesType | null | undefined;
  /**
   * The updated_at date of this policy
   */
  updatedAt?: Date | null | undefined;
};

export type TimeOffBalances = {
  /**
   * The date of when the current balance expires
   */
  balanceExpiryDate?: Date | null | undefined;
  /**
   * The date of when the initial balance quantity was set
   */
  balanceStartDate?: Date | null | undefined;
  /**
   * The duration unit of the current balance
   */
  balanceUnit?: BalanceUnit | null | undefined;
  /**
   * The current numeric balance for the associated employee and time off policy
   */
  currentBalance?: number | null | undefined;
  /**
   * The employee id associated with this balance
   */
  employeeId?: string | null | undefined;
  /**
   * Unique identifier
   */
  id?: string | null | undefined;
  /**
   * The initial numeric balance for the associated employee and time off policy as of the balance start date
   */
  initialBalance?: number | null | undefined;
  /**
   * Indicates if this time off balance represents unlimited leave
   */
  isUnlimited?: boolean | TimeOffBalances2 | null | undefined;
  /**
   * The time off policy associated with this balance
   */
  policy?: TimeOffBalancesPolicy | null | undefined;
  /**
   * The time off policy id associated with this balance
   */
  policyId?: string | null | undefined;
  /**
   * Provider's unique identifier of the employee associated with this balance
   */
  remoteEmployeeId?: string | null | undefined;
  /**
   * Provider's unique identifier
   */
  remoteId?: string | null | undefined;
  /**
   * Provider's unique identifier of the time off policy id associated with this balance
   */
  remotePolicyId?: string | null | undefined;
  /**
   * The updated_at date of this time off balance
   */
  updatedAt?: Date | null | undefined;
};

/** @internal */
export const TimeOffBalances4$inboundSchema: z.ZodType<
  TimeOffBalances4,
  z.ZodTypeDef,
  unknown
> = z.object({});

export function timeOffBalances4FromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalances4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalances4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalances4' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesSourceValue$inboundSchema: z.ZodType<
  TimeOffBalancesSourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => TimeOffBalances4$inboundSchema),
  z.array(z.any()),
]);

export function timeOffBalancesSourceValueFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalancesSourceValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalancesSourceValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalancesSourceValue' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesValue$inboundSchema: z.ZodType<
  TimeOffBalancesValueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimeOffBalancesValue),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const BalanceUnit$inboundSchema: z.ZodType<
  BalanceUnit,
  z.ZodTypeDef,
  unknown
> = z.object({
  source_value: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => TimeOffBalances4$inboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(TimeOffBalancesValue$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "source_value": "sourceValue",
  });
});

export function balanceUnitFromJSON(
  jsonString: string,
): SafeParseResult<BalanceUnit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BalanceUnit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BalanceUnit' from JSON`,
  );
}

/** @internal */
export const TimeOffBalances2$inboundSchema: z.ZodNativeEnum<
  typeof TimeOffBalances2
> = z.nativeEnum(TimeOffBalances2);

/** @internal */
export const IsUnlimited$inboundSchema: z.ZodType<
  IsUnlimited,
  z.ZodTypeDef,
  unknown
> = z.union([z.boolean(), TimeOffBalances2$inboundSchema]);

export function isUnlimitedFromJSON(
  jsonString: string,
): SafeParseResult<IsUnlimited, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IsUnlimited$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IsUnlimited' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesSchemas4$inboundSchema: z.ZodType<
  TimeOffBalancesSchemas4,
  z.ZodTypeDef,
  unknown
> = z.object({});

export function timeOffBalancesSchemas4FromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalancesSchemas4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalancesSchemas4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalancesSchemas4' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesSchemasSourceValue$inboundSchema: z.ZodType<
  TimeOffBalancesSchemasSourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => TimeOffBalancesSchemas4$inboundSchema),
  z.array(z.any()),
]);

export function timeOffBalancesSchemasSourceValueFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalancesSchemasSourceValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalancesSchemasSourceValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalancesSchemasSourceValue' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesSchemasValue$inboundSchema: z.ZodType<
  TimeOffBalancesSchemasValueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimeOffBalancesSchemasValue),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TimeOffBalancesDurationUnit$inboundSchema: z.ZodType<
  TimeOffBalancesDurationUnit,
  z.ZodTypeDef,
  unknown
> = z.object({
  source_value: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => TimeOffBalancesSchemas4$inboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(TimeOffBalancesSchemasValue$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "source_value": "sourceValue",
  });
});

export function timeOffBalancesDurationUnitFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalancesDurationUnit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalancesDurationUnit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalancesDurationUnit' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesSchemasPolicy4$inboundSchema: z.ZodType<
  TimeOffBalancesSchemasPolicy4,
  z.ZodTypeDef,
  unknown
> = z.object({});

export function timeOffBalancesSchemasPolicy4FromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalancesSchemasPolicy4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalancesSchemasPolicy4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalancesSchemasPolicy4' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesSchemasPolicySourceValue$inboundSchema: z.ZodType<
  TimeOffBalancesSchemasPolicySourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => TimeOffBalancesSchemasPolicy4$inboundSchema),
  z.array(z.any()),
]);

export function timeOffBalancesSchemasPolicySourceValueFromJSON(
  jsonString: string,
): SafeParseResult<
  TimeOffBalancesSchemasPolicySourceValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      TimeOffBalancesSchemasPolicySourceValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'TimeOffBalancesSchemasPolicySourceValue' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesSchemasPolicyValue$inboundSchema: z.ZodType<
  TimeOffBalancesSchemasPolicyValueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TimeOffBalancesSchemasPolicyValue),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TimeOffBalancesType$inboundSchema: z.ZodType<
  TimeOffBalancesType,
  z.ZodTypeDef,
  unknown
> = z.object({
  source_value: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => TimeOffBalancesSchemasPolicy4$inboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(TimeOffBalancesSchemasPolicyValue$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "source_value": "sourceValue",
  });
});

export function timeOffBalancesTypeFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalancesType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalancesType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalancesType' from JSON`,
  );
}

/** @internal */
export const TimeOffBalancesPolicy$inboundSchema: z.ZodType<
  TimeOffBalancesPolicy,
  z.ZodTypeDef,
  unknown
> = z.object({
  created_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  description: z.nullable(z.string()).optional(),
  duration_unit: z.nullable(
    z.lazy(() => TimeOffBalancesDurationUnit$inboundSchema),
  ).optional(),
  id: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  reasons: z.nullable(z.array(Reason$inboundSchema)).optional(),
  remote_id: z.nullable(z.string()).optional(),
  type: z.nullable(z.lazy(() => TimeOffBalancesType$inboundSchema)).optional(),
  updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
    "duration_unit": "durationUnit",
    "remote_id": "remoteId",
    "updated_at": "updatedAt",
  });
});

export function timeOffBalancesPolicyFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalancesPolicy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalancesPolicy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalancesPolicy' from JSON`,
  );
}

/** @internal */
export const TimeOffBalances$inboundSchema: z.ZodType<
  TimeOffBalances,
  z.ZodTypeDef,
  unknown
> = z.object({
  balance_expiry_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  balance_start_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  balance_unit: z.nullable(z.lazy(() => BalanceUnit$inboundSchema)).optional(),
  current_balance: z.nullable(z.number()).optional(),
  employee_id: z.nullable(z.string()).optional(),
  id: z.nullable(z.string()).optional(),
  initial_balance: z.nullable(z.number()).optional(),
  is_unlimited: z.nullable(
    z.union([z.boolean(), TimeOffBalances2$inboundSchema]),
  ).optional(),
  policy: z.nullable(z.lazy(() => TimeOffBalancesPolicy$inboundSchema))
    .optional(),
  policy_id: z.nullable(z.string()).optional(),
  remote_employee_id: z.nullable(z.string()).optional(),
  remote_id: z.nullable(z.string()).optional(),
  remote_policy_id: z.nullable(z.string()).optional(),
  updated_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "balance_expiry_date": "balanceExpiryDate",
    "balance_start_date": "balanceStartDate",
    "balance_unit": "balanceUnit",
    "current_balance": "currentBalance",
    "employee_id": "employeeId",
    "initial_balance": "initialBalance",
    "is_unlimited": "isUnlimited",
    "policy_id": "policyId",
    "remote_employee_id": "remoteEmployeeId",
    "remote_id": "remoteId",
    "remote_policy_id": "remotePolicyId",
    "updated_at": "updatedAt",
  });
});

export function timeOffBalancesFromJSON(
  jsonString: string,
): SafeParseResult<TimeOffBalances, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimeOffBalances$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimeOffBalances' from JSON`,
  );
}
