/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export enum Category2 {
  True = "true",
  False = "false",
}

/**
 * Whether the category is active and therefore available for use
 */
export type CategoryActive = boolean | Category2;

export type Category4 = {};

/**
 * For read operations: the original category level from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format.
 */
export type CategorySourceValue =
  | string
  | number
  | boolean
  | Category4
  | Array<any>;

/**
 * The unified category level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
 */
export enum CategoryValue {
  Primary = "primary",
  Secondary = "secondary",
  Tertiary = "tertiary",
  UnmappedValue = "unmapped_value",
}
/**
 * The unified category level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
 */
export type CategoryValueOpen = OpenEnum<typeof CategoryValue>;

/**
 * The hierarchal level of the category
 */
export type Hierarchy = {
  /**
   * For read operations: the original category level from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format.
   */
  sourceValue?:
    | string
    | number
    | boolean
    | Category4
    | Array<any>
    | null
    | undefined;
  /**
   * The unified category level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
   */
  value?: CategoryValueOpen | null | undefined;
};

export type CategorySchemas4 = {};

/**
 * For read operations: the original language code from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format.
 */
export type CategorySchemasSourceValue =
  | string
  | number
  | boolean
  | CategorySchemas4
  | Array<any>;

/**
 * The unified locale code. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
 */
export enum CategorySchemasValue {
  ARAR = "ar_AR",
  AaER = "aa_ER",
  AfNA = "af_NA",
  AfZA = "af_ZA",
  AmET = "am_ET",
  ArAE = "ar_AE",
  ArBH = "ar_BH",
  ArDJ = "ar_DJ",
  ArDZ = "ar_DZ",
  ArEG = "ar_EG",
  ArER = "ar_ER",
  ArIQ = "ar_IQ",
  ArJO = "ar_JO",
  ArKM = "ar_KM",
  ArKW = "ar_KW",
  ArLB = "ar_LB",
  ArLY = "ar_LY",
  ArMA = "ar_MA",
  ArMR = "ar_MR",
  ArOM = "ar_OM",
  ArPS = "ar_PS",
  ArQA = "ar_QA",
  ArSA = "ar_SA",
  ArSD = "ar_SD",
  ArSY = "ar_SY",
  ArTD = "ar_TD",
  ArTN = "ar_TN",
  ArYE = "ar_YE",
  AyBO = "ay_BO",
  AyPE = "ay_PE",
  AZAZ = "az_AZ",
  AzIR = "az_IR",
  BeBY = "be_BY",
  BGBG = "bg_BG",
  BiVU = "bi_VU",
  BnBD = "bn_BD",
  BnIN = "bn_IN",
  BsBA = "bs_BA",
  BsME = "bs-ME",
  BynER = "byn_ER",
  CaAD = "ca_AD",
  CaES = "ca_ES",
  CaFR = "ca_FR",
  CaIT = "ca_IT",
  ChGU = "ch_GU",
  CsCZ = "cs_CZ",
  DaDK = "da_DK",
  DeAT = "de_AT",
  DeBE = "de_BE",
  DeCH = "de_CH",
  DEDE = "de_DE",
  DeLI = "de_LI",
  DeLU = "de_LU",
  DeVA = "de_VA",
  DeMV = "de_MV",
  DvMV = "dv_MV",
  DzBT = "dz_BT",
  ElCY = "el_CY",
  ElGR = "el_GR",
  EnAG = "en_AG",
  EnAI = "en_AI",
  EnAS = "en_AS",
  EnAU = "en_AU",
  EnBB = "en_BB",
  EnBE = "en_BE",
  EnBM = "en_BM",
  EnBS = "en_BS",
  EnBW = "en_BW",
  EnBZ = "en_BZ",
  EnCA = "en_CA",
  EnCC = "en_CC",
  EnCK = "en_CK",
  EnCM = "en_CM",
  EnCW = "en_CW",
  EnCX = "en_CX",
  EnDG = "en_DG",
  EnDM = "en_DM",
  EnER = "en_ER",
  EnFJ = "en_FJ",
  EnFK = "en_FK",
  EnFM = "en_FM",
  EnGB = "en_GB",
  EnGD = "en_GD",
  EnGG = "en_GG",
  EnGH = "en_GH",
  EnGI = "en_GI",
  EnGM = "en_GM",
  EnGS = "en_GS",
  EnGU = "en_GU",
  EnGY = "en_GY",
  EnHK = "en_HK",
  EnIE = "en_IE",
  EnIM = "en_IM",
  EnIN = "en_IN",
  EnIO = "en_IO",
  EnJE = "en_JE",
  EnJM = "en_JM",
  EnKE = "en_KE",
  EnKI = "en_KI",
  EnKN = "en_KN",
  EnKY = "en_KY",
  EnLC = "en_LC",
  EnLR = "en_LR",
  EnLS = "en_LS",
  EnMF = "en_MF",
  EnMG = "en_MG",
  EnMH = "en_MH",
  EnMO = "en_MO",
  EnMP = "en_MP",
  EnMS = "en_MS",
  EnMT = "en_MT",
  EnMU = "en_MU",
  EnMW = "en_MW",
  EnMY = "en_MY",
  EnNA = "en_NA",
  EnNF = "en_NF",
  EnNG = "en_NG",
  EnNL = "en_NL",
  EnNR = "en_NR",
  EnNU = "en_NU",
  EnNZ = "en_NZ",
  EnPG = "en_PG",
  EnPH = "en_PH",
  EnPK = "en_PK",
  EnPN = "en_PN",
  EnPR = "en_PR",
  EnPW = "en_PW",
  EnRW = "en_RW",
  EnSB = "en_SB",
  EnSC = "en_SC",
  EnSD = "en_SD",
  EnSG = "en_SG",
  EnSH = "en_SH",
  EnSL = "en_SL",
  EnSS = "en_SS",
  EnSX = "en_SX",
  EnSZ = "en_SZ",
  EnTC = "en_TC",
  EnTK = "en_TK",
  EnTO = "en_TO",
  EnTT = "en_TT",
  EnTV = "en_TV",
  EnTZ = "en_TZ",
  EnUG = "en_UG",
  EnUM = "en_UM",
  EnUS = "en_US",
  EnVC = "en_VC",
  EnVG = "en_VG",
  EnVI = "en_VI",
  EnVU = "en_VU",
  EnWS = "en_WS",
  EnZA = "en_ZA",
  EnZM = "en_ZM",
  EnZW = "en_ZW",
  EsAR = "es_AR",
  EsBO = "es_BO",
  EsBZ = "es_BZ",
  EsCL = "es_CL",
  EsCO = "es_CO",
  EsCR = "es_CR",
  EsCU = "es_CU",
  EsDO = "es_DO",
  EsEA = "es_EA",
  EsEC = "es_EC",
  EsEH = "es_EH",
  ESES = "es_ES",
  EsGQ = "es_GQ",
  EsGT = "es_GT",
  EsHN = "es_HN",
  EsIC = "es_IC",
  EsLA = "es_LA",
  EsMX = "es_MX",
  EsNI = "es_NI",
  EsPA = "es_PA",
  EsPE = "es_PE",
  EsPH = "es_PH",
  EsPR = "es_PR",
  EsPY = "es_PY",
  EsSV = "es_SV",
  EsUS = "es_US",
  EsUY = "es_UY",
  EsVE = "es_VE",
  EtEE = "et_EE",
  FaAF = "fa_AF",
  FaIR = "fa_IR",
  FanGA = "fan_GA",
  FfCM = "ff_CM",
  FfGN = "ff_GN",
  FfMR = "ff_MR",
  FfSN = "ff_SN",
  FfBF = "ff_BF",
  FIFI = "fi_FI",
  FJFJ = "fj_FJ",
  FOFO = "fo_FO",
  FrBE = "fr_BE",
  FrBF = "fr_BF",
  FrBI = "fr_BI",
  FrBJ = "fr_BJ",
  FrBL = "fr_BL",
  FrCA = "fr_CA",
  FrCD = "fr_CD",
  FrCF = "fr_CF",
  FrCG = "fr_CG",
  FrCH = "fr_CH",
  FrCI = "fr_CI",
  FrCM = "fr_CM",
  FrDJ = "fr_DJ",
  FrDZ = "fr_DZ",
  FRFR = "fr_FR",
  FrGA = "fr_GA",
  FrGF = "fr_GF",
  FrGG = "fr_GG",
  FrGN = "fr_GN",
  FrGP = "fr_GP",
  FrGQ = "fr_GQ",
  FrHT = "fr_HT",
  FrKM = "fr_KM",
  FrJE = "fr_JE",
  FrLU = "fr_LU",
  FrLB = "fr_LB",
  FrMA = "fr_MA",
  FrMC = "fr_MC",
  FrMF = "fr_MF",
  FrMG = "fr_MG",
  FrML = "fr_ML",
  FrMQ = "fr_MQ",
  FrMR = "fr_MR",
  FrMU = "fr_MU",
  FrNC = "fr_NC",
  FrNE = "fr_NE",
  FrPF = "fr_PF",
  FrPM = "fr_PM",
  FrRE = "fr_RE",
  FrRW = "fr_RW",
  FrSC = "fr_SC",
  FrSN = "fr_SN",
  FrSY = "fr_SY",
  FrTD = "fr_TD",
  FrTF = "fr_TF",
  FrTG = "fr_TG",
  FrTN = "fr_TN",
  FrVU = "fr_VU",
  FrVA = "fr_VA",
  FrWF = "fr_WF",
  FrYT = "fr_YT",
  GaIE = "ga_IE",
  GnPY = "gn_PY",
  GnAR = "gn_AR",
  GuIN = "gu_IN",
  GvIM = "gv_IM",
  HeIL = "he_IL",
  HiIN = "hi_IN",
  HrBA = "hr_BA",
  HRHR = "hr_HR",
  HrME = "hr_ME",
  HTHT = "ht_HT",
  HUHU = "hu_HU",
  HyAM = "hy_AM",
  HyCY = "hy_CY",
  IDID = "id_ID",
  ISIS = "is_IS",
  ItCH = "it_CH",
  ITIT = "it_IT",
  ItSM = "it_SM",
  ItVA = "it_VA",
  JaJP = "ja_JP",
  KaGE = "ka_GE",
  KgCD = "kg_CD",
  KkKZ = "kk_KZ",
  KlGL = "kl_GL",
  KmKH = "km_KH",
  KoKP = "ko_KP",
  KoKR = "ko_KR",
  KuIQ = "ku_IQ",
  KyKG = "ky_KG",
  LaVA = "la_VA",
  LbLU = "lb_LU",
  LnAO = "ln_AO",
  LnCD = "ln_CD",
  LnCF = "ln_CF",
  LnCG = "ln_CG",
  LoLA = "lo_LA",
  LTLT = "lt_LT",
  LuCD = "lu_CD",
  LVLV = "lv_LV",
  MGMG = "mg_MG",
  MHMH = "mh_MH",
  MiNZ = "mi_NZ",
  MKMK = "mk_MK",
  MNMN = "mn_MN",
  MrIN = "mr_IN",
  MsBN = "ms_BN",
  MsMY = "ms_MY",
  MsSG = "ms_SG",
  MTMT = "mt_MT",
  MyMM = "my_MM",
  NbNO = "nb_NO",
  NbBV = "nb_BV",
  NbZW = "nb_ZW",
  NeNP = "ne_NP",
  NlAW = "nl_AW",
  NlBE = "nl_BE",
  NlBQ = "nl_BQ",
  NlCW = "nl_CW",
  NLNL = "nl_NL",
  NlSR = "nl_SR",
  NlSX = "nl_SX",
  NlMF = "nl_MF",
  NnNO = "nn_NO",
  NnBV = "nn_BV",
  NONO = "no_NO",
  NoBV = "no_BV",
  NoSJ = "no_SJ",
  NrZA = "nr_ZA",
  NyMW = "ny_MW",
  PaIN = "pa_IN",
  PaPK = "pa_PK",
  PLPL = "pl_PL",
  PsAF = "ps_AF",
  PtAO = "pt_AO",
  PtBR = "pt_BR",
  PtCH = "pt_CH",
  PtCV = "pt_CV",
  PtGQ = "pt_GQ",
  PtGW = "pt_GW",
  PtLU = "pt_LU",
  PtMO = "pt_MO",
  PtMZ = "pt_MZ",
  PTPT = "pt_PT",
  PtST = "pt_ST",
  PtTL = "pt_TL",
  QuBO = "qu_BO",
  QuEC = "qu_EC",
  QuPE = "qu_PE",
  RarCK = "rar_CK",
  RmCH = "rm_CH",
  RupMK = "rup_MK",
  RoMD = "ro_MD",
  RORO = "ro_RO",
  RuBY = "ru_BY",
  RuKG = "ru_KG",
  RuKZ = "ru_KZ",
  RuMD = "ru_MD",
  RURU = "ru_RU",
  RuUA = "ru_UA",
  RuAQ = "ru_AQ",
  RuTJ = "ru_TJ",
  RuTM = "ru_TM",
  RuUZ = "ru_UZ",
  RWRW = "rw_RW",
  SESE = "se_SE",
  SgCF = "sg_CF",
  SiLK = "si_LK",
  SKSK = "sk_SK",
  SlSI = "sl_SI",
  SmAS = "sm_AS",
  SmWS = "sm_WS",
  SnZW = "sn_ZW",
  SoDJ = "so_DJ",
  SoET = "so_ET",
  SoKE = "so_KE",
  SOSO = "so_SO",
  SqAL = "sq_AL",
  SqME = "sq_ME",
  SqXK = "sq_XK",
  SrBA = "sr_BA",
  SrME = "sr_ME",
  SrRS = "sr_RS",
  SrXK = "sr_XK",
  SsSZ = "ss_SZ",
  SsZA = "ss_ZA",
  SvAX = "sv_AX",
  SvFI = "sv_FI",
  SvSE = "sv_SE",
  SwKE = "sw_KE",
  SwTZ = "sw_TZ",
  SwUG = "sw_UG",
  SwCD = "sw_CD",
  TaIN = "ta_IN",
  TaMY = "ta_MY",
  TaSG = "ta_SG",
  TaLK = "ta_LK",
  TeIN = "te_IN",
  TgTJ = "tg_TJ",
  THTH = "th_TH",
  TiER = "ti_ER",
  TiET = "ti_ET",
  TigER = "tig_ER",
  TkTM = "tk_TM",
  TkAF = "tk_AF",
  TnBW = "tn_BW",
  TnZA = "tn_ZA",
  TOTO = "to_TO",
  TrCY = "tr_CY",
  TRTR = "tr_TR",
  TsZA = "ts_ZA",
  UkUA = "uk_UA",
  UrIN = "ur_IN",
  UrPK = "ur_PK",
  UzAF = "uz_AF",
  UZUZ = "uz_UZ",
  VeZA = "ve_ZA",
  ViVN = "vi_VN",
  XhZA = "xh_ZA",
  ZhCN = "zh_CN",
  ZhHK = "zh_HK",
  ZhMO = "zh_MO",
  ZhSG = "zh_SG",
  ZhTW = "zh_TW",
  ZuZA = "zu_ZA",
  UnmappedValue = "unmapped_value",
}
/**
 * The unified locale code. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
 */
export type CategorySchemasValueOpen = OpenEnum<typeof CategorySchemasValue>;

/**
 * The language associated with this category
 */
export type Language = {
  /**
   * For read operations: the original language code from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format.
   */
  sourceValue?:
    | string
    | number
    | boolean
    | CategorySchemas4
    | Array<any>
    | null
    | undefined;
  /**
   * The unified locale code. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
   */
  value?: CategorySchemasValueOpen | null | undefined;
};

export type CategorySchemasLevel4 = {};

/**
 * For read operations: the original category level from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format.
 */
export type CategorySchemasLevelSourceValue =
  | string
  | number
  | boolean
  | CategorySchemasLevel4
  | Array<any>;

/**
 * The unified category level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
 */
export enum CategorySchemasLevelValue {
  Primary = "primary",
  Secondary = "secondary",
  Tertiary = "tertiary",
  UnmappedValue = "unmapped_value",
}
/**
 * The unified category level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
 */
export type CategorySchemasLevelValueOpen = OpenEnum<
  typeof CategorySchemasLevelValue
>;

/**
 * The hierarchal level of the category
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type Level = {
  /**
   * For read operations: the original category level from the provider. For write operations: fallback value used when value is omitted or "unmapped_value". You must ensure this matches the provider's format.
   */
  sourceValue?:
    | string
    | number
    | boolean
    | CategorySchemasLevel4
    | Array<any>
    | null
    | undefined;
  /**
   * The unified category level. For write operations: provide one of the listed enum values, or omit/set to "unmapped_value" to use source_value instead.
   */
  value?: CategorySchemasLevelValueOpen | null | undefined;
};

export type Category = {
  /**
   * Whether the category is active and therefore available for use
   */
  active?: boolean | Category2 | null | undefined;
  /**
   * The hierarchal level of the category
   */
  hierarchy?: Hierarchy | null | undefined;
  /**
   * The ID associated with this category
   */
  id?: string | null | undefined;
  /**
   * The language associated with this category
   */
  language?: Language | null | undefined;
  /**
   * The hierarchal level of the category
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  level?: Level | null | undefined;
  /**
   * The name associated with this category
   */
  name?: string | null | undefined;
  /**
   * Provider's unique identifier
   */
  remoteId?: string | null | undefined;
  /**
   * Custom Unified Fields configured in your StackOne project
   */
  unifiedCustomFields?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const Category2$inboundSchema: z.ZodNativeEnum<typeof Category2> = z
  .nativeEnum(Category2);
/** @internal */
export const Category2$outboundSchema: z.ZodNativeEnum<typeof Category2> =
  Category2$inboundSchema;

/** @internal */
export const CategoryActive$inboundSchema: z.ZodType<
  CategoryActive,
  z.ZodTypeDef,
  unknown
> = z.union([z.boolean(), Category2$inboundSchema]);
/** @internal */
export type CategoryActive$Outbound = boolean | string;

/** @internal */
export const CategoryActive$outboundSchema: z.ZodType<
  CategoryActive$Outbound,
  z.ZodTypeDef,
  CategoryActive
> = z.union([z.boolean(), Category2$outboundSchema]);

export function categoryActiveToJSON(categoryActive: CategoryActive): string {
  return JSON.stringify(CategoryActive$outboundSchema.parse(categoryActive));
}
export function categoryActiveFromJSON(
  jsonString: string,
): SafeParseResult<CategoryActive, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategoryActive$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategoryActive' from JSON`,
  );
}

/** @internal */
export const Category4$inboundSchema: z.ZodType<
  Category4,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type Category4$Outbound = {};

/** @internal */
export const Category4$outboundSchema: z.ZodType<
  Category4$Outbound,
  z.ZodTypeDef,
  Category4
> = z.object({});

export function category4ToJSON(category4: Category4): string {
  return JSON.stringify(Category4$outboundSchema.parse(category4));
}
export function category4FromJSON(
  jsonString: string,
): SafeParseResult<Category4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Category4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Category4' from JSON`,
  );
}

/** @internal */
export const CategorySourceValue$inboundSchema: z.ZodType<
  CategorySourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Category4$inboundSchema),
  z.array(z.any()),
]);
/** @internal */
export type CategorySourceValue$Outbound =
  | string
  | number
  | boolean
  | Category4$Outbound
  | Array<any>;

/** @internal */
export const CategorySourceValue$outboundSchema: z.ZodType<
  CategorySourceValue$Outbound,
  z.ZodTypeDef,
  CategorySourceValue
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Category4$outboundSchema),
  z.array(z.any()),
]);

export function categorySourceValueToJSON(
  categorySourceValue: CategorySourceValue,
): string {
  return JSON.stringify(
    CategorySourceValue$outboundSchema.parse(categorySourceValue),
  );
}
export function categorySourceValueFromJSON(
  jsonString: string,
): SafeParseResult<CategorySourceValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategorySourceValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategorySourceValue' from JSON`,
  );
}

/** @internal */
export const CategoryValue$inboundSchema: z.ZodType<
  CategoryValueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CategoryValue),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const CategoryValue$outboundSchema: z.ZodType<
  CategoryValueOpen,
  z.ZodTypeDef,
  CategoryValueOpen
> = z.union([
  z.nativeEnum(CategoryValue),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const Hierarchy$inboundSchema: z.ZodType<
  Hierarchy,
  z.ZodTypeDef,
  unknown
> = z.object({
  source_value: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => Category4$inboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(CategoryValue$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "source_value": "sourceValue",
  });
});
/** @internal */
export type Hierarchy$Outbound = {
  source_value?:
    | string
    | number
    | boolean
    | Category4$Outbound
    | Array<any>
    | null
    | undefined;
  value?: string | null | undefined;
};

/** @internal */
export const Hierarchy$outboundSchema: z.ZodType<
  Hierarchy$Outbound,
  z.ZodTypeDef,
  Hierarchy
> = z.object({
  sourceValue: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => Category4$outboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(CategoryValue$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    sourceValue: "source_value",
  });
});

export function hierarchyToJSON(hierarchy: Hierarchy): string {
  return JSON.stringify(Hierarchy$outboundSchema.parse(hierarchy));
}
export function hierarchyFromJSON(
  jsonString: string,
): SafeParseResult<Hierarchy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Hierarchy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Hierarchy' from JSON`,
  );
}

/** @internal */
export const CategorySchemas4$inboundSchema: z.ZodType<
  CategorySchemas4,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type CategorySchemas4$Outbound = {};

/** @internal */
export const CategorySchemas4$outboundSchema: z.ZodType<
  CategorySchemas4$Outbound,
  z.ZodTypeDef,
  CategorySchemas4
> = z.object({});

export function categorySchemas4ToJSON(
  categorySchemas4: CategorySchemas4,
): string {
  return JSON.stringify(
    CategorySchemas4$outboundSchema.parse(categorySchemas4),
  );
}
export function categorySchemas4FromJSON(
  jsonString: string,
): SafeParseResult<CategorySchemas4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategorySchemas4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategorySchemas4' from JSON`,
  );
}

/** @internal */
export const CategorySchemasSourceValue$inboundSchema: z.ZodType<
  CategorySchemasSourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => CategorySchemas4$inboundSchema),
  z.array(z.any()),
]);
/** @internal */
export type CategorySchemasSourceValue$Outbound =
  | string
  | number
  | boolean
  | CategorySchemas4$Outbound
  | Array<any>;

/** @internal */
export const CategorySchemasSourceValue$outboundSchema: z.ZodType<
  CategorySchemasSourceValue$Outbound,
  z.ZodTypeDef,
  CategorySchemasSourceValue
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => CategorySchemas4$outboundSchema),
  z.array(z.any()),
]);

export function categorySchemasSourceValueToJSON(
  categorySchemasSourceValue: CategorySchemasSourceValue,
): string {
  return JSON.stringify(
    CategorySchemasSourceValue$outboundSchema.parse(categorySchemasSourceValue),
  );
}
export function categorySchemasSourceValueFromJSON(
  jsonString: string,
): SafeParseResult<CategorySchemasSourceValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategorySchemasSourceValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategorySchemasSourceValue' from JSON`,
  );
}

/** @internal */
export const CategorySchemasValue$inboundSchema: z.ZodType<
  CategorySchemasValueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CategorySchemasValue),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const CategorySchemasValue$outboundSchema: z.ZodType<
  CategorySchemasValueOpen,
  z.ZodTypeDef,
  CategorySchemasValueOpen
> = z.union([
  z.nativeEnum(CategorySchemasValue),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const Language$inboundSchema: z.ZodType<
  Language,
  z.ZodTypeDef,
  unknown
> = z.object({
  source_value: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => CategorySchemas4$inboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(CategorySchemasValue$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "source_value": "sourceValue",
  });
});
/** @internal */
export type Language$Outbound = {
  source_value?:
    | string
    | number
    | boolean
    | CategorySchemas4$Outbound
    | Array<any>
    | null
    | undefined;
  value?: string | null | undefined;
};

/** @internal */
export const Language$outboundSchema: z.ZodType<
  Language$Outbound,
  z.ZodTypeDef,
  Language
> = z.object({
  sourceValue: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => CategorySchemas4$outboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(CategorySchemasValue$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    sourceValue: "source_value",
  });
});

export function languageToJSON(language: Language): string {
  return JSON.stringify(Language$outboundSchema.parse(language));
}
export function languageFromJSON(
  jsonString: string,
): SafeParseResult<Language, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Language$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Language' from JSON`,
  );
}

/** @internal */
export const CategorySchemasLevel4$inboundSchema: z.ZodType<
  CategorySchemasLevel4,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type CategorySchemasLevel4$Outbound = {};

/** @internal */
export const CategorySchemasLevel4$outboundSchema: z.ZodType<
  CategorySchemasLevel4$Outbound,
  z.ZodTypeDef,
  CategorySchemasLevel4
> = z.object({});

export function categorySchemasLevel4ToJSON(
  categorySchemasLevel4: CategorySchemasLevel4,
): string {
  return JSON.stringify(
    CategorySchemasLevel4$outboundSchema.parse(categorySchemasLevel4),
  );
}
export function categorySchemasLevel4FromJSON(
  jsonString: string,
): SafeParseResult<CategorySchemasLevel4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategorySchemasLevel4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategorySchemasLevel4' from JSON`,
  );
}

/** @internal */
export const CategorySchemasLevelSourceValue$inboundSchema: z.ZodType<
  CategorySchemasLevelSourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => CategorySchemasLevel4$inboundSchema),
  z.array(z.any()),
]);
/** @internal */
export type CategorySchemasLevelSourceValue$Outbound =
  | string
  | number
  | boolean
  | CategorySchemasLevel4$Outbound
  | Array<any>;

/** @internal */
export const CategorySchemasLevelSourceValue$outboundSchema: z.ZodType<
  CategorySchemasLevelSourceValue$Outbound,
  z.ZodTypeDef,
  CategorySchemasLevelSourceValue
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => CategorySchemasLevel4$outboundSchema),
  z.array(z.any()),
]);

export function categorySchemasLevelSourceValueToJSON(
  categorySchemasLevelSourceValue: CategorySchemasLevelSourceValue,
): string {
  return JSON.stringify(
    CategorySchemasLevelSourceValue$outboundSchema.parse(
      categorySchemasLevelSourceValue,
    ),
  );
}
export function categorySchemasLevelSourceValueFromJSON(
  jsonString: string,
): SafeParseResult<CategorySchemasLevelSourceValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategorySchemasLevelSourceValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategorySchemasLevelSourceValue' from JSON`,
  );
}

/** @internal */
export const CategorySchemasLevelValue$inboundSchema: z.ZodType<
  CategorySchemasLevelValueOpen,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CategorySchemasLevelValue),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const CategorySchemasLevelValue$outboundSchema: z.ZodType<
  CategorySchemasLevelValueOpen,
  z.ZodTypeDef,
  CategorySchemasLevelValueOpen
> = z.union([
  z.nativeEnum(CategorySchemasLevelValue),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const Level$inboundSchema: z.ZodType<Level, z.ZodTypeDef, unknown> = z
  .object({
    source_value: z.nullable(
      z.union([
        z.string(),
        z.number(),
        z.boolean(),
        z.lazy(() => CategorySchemasLevel4$inboundSchema),
        z.array(z.any()),
      ]),
    ).optional(),
    value: z.nullable(CategorySchemasLevelValue$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "source_value": "sourceValue",
    });
  });
/** @internal */
export type Level$Outbound = {
  source_value?:
    | string
    | number
    | boolean
    | CategorySchemasLevel4$Outbound
    | Array<any>
    | null
    | undefined;
  value?: string | null | undefined;
};

/** @internal */
export const Level$outboundSchema: z.ZodType<
  Level$Outbound,
  z.ZodTypeDef,
  Level
> = z.object({
  sourceValue: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => CategorySchemasLevel4$outboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(CategorySchemasLevelValue$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    sourceValue: "source_value",
  });
});

export function levelToJSON(level: Level): string {
  return JSON.stringify(Level$outboundSchema.parse(level));
}
export function levelFromJSON(
  jsonString: string,
): SafeParseResult<Level, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Level$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Level' from JSON`,
  );
}

/** @internal */
export const Category$inboundSchema: z.ZodType<
  Category,
  z.ZodTypeDef,
  unknown
> = z.object({
  active: z.nullable(z.union([z.boolean(), Category2$inboundSchema]))
    .optional(),
  hierarchy: z.nullable(z.lazy(() => Hierarchy$inboundSchema)).optional(),
  id: z.nullable(z.string()).optional(),
  language: z.nullable(z.lazy(() => Language$inboundSchema)).optional(),
  level: z.nullable(z.lazy(() => Level$inboundSchema)).optional(),
  name: z.nullable(z.string()).optional(),
  remote_id: z.nullable(z.string()).optional(),
  unified_custom_fields: z.nullable(z.record(z.any())).optional(),
}).transform((v) => {
  return remap$(v, {
    "remote_id": "remoteId",
    "unified_custom_fields": "unifiedCustomFields",
  });
});
/** @internal */
export type Category$Outbound = {
  active?: boolean | string | null | undefined;
  hierarchy?: Hierarchy$Outbound | null | undefined;
  id?: string | null | undefined;
  language?: Language$Outbound | null | undefined;
  level?: Level$Outbound | null | undefined;
  name?: string | null | undefined;
  remote_id?: string | null | undefined;
  unified_custom_fields?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const Category$outboundSchema: z.ZodType<
  Category$Outbound,
  z.ZodTypeDef,
  Category
> = z.object({
  active: z.nullable(z.union([z.boolean(), Category2$outboundSchema]))
    .optional(),
  hierarchy: z.nullable(z.lazy(() => Hierarchy$outboundSchema)).optional(),
  id: z.nullable(z.string()).optional(),
  language: z.nullable(z.lazy(() => Language$outboundSchema)).optional(),
  level: z.nullable(z.lazy(() => Level$outboundSchema)).optional(),
  name: z.nullable(z.string()).optional(),
  remoteId: z.nullable(z.string()).optional(),
  unifiedCustomFields: z.nullable(z.record(z.any())).optional(),
}).transform((v) => {
  return remap$(v, {
    remoteId: "remote_id",
    unifiedCustomFields: "unified_custom_fields",
  });
});

export function categoryToJSON(category: Category): string {
  return JSON.stringify(Category$outboundSchema.parse(category));
}
export function categoryFromJSON(
  jsonString: string,
): SafeParseResult<Category, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Category$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Category' from JSON`,
  );
}
