/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  QuestionMultipleChoiceAnswers,
  QuestionMultipleChoiceAnswers$inboundSchema,
} from "./questionmultiplechoiceanswers.js";

export type QuestionSchemas4 = {};

/**
 * The source value of the question's condition type
 */
export type QuestionSchemasSourceValue =
  | string
  | number
  | boolean
  | QuestionSchemas4
  | Array<any>;

/**
 * The type of the question's condition
 */
export enum QuestionSchemasValue {
  EqualsTo = "equals_to",
  Contains = "contains",
  UnmappedValue = "unmapped_value",
}
/**
 * The type of the question's condition
 */
export type QuestionSchemasValueOpen = OpenEnum<typeof QuestionSchemasValue>;

export type ConditionType = {
  /**
   * The source value of the question's condition type
   */
  sourceValue?:
    | string
    | number
    | boolean
    | QuestionSchemas4
    | Array<any>
    | null
    | undefined;
  /**
   * The type of the question's condition
   */
  value?: QuestionSchemasValueOpen | null | undefined;
};

export type ParentQuestion = {
  conditionType?: ConditionType | null | undefined;
  /**
   * Unique identifier
   */
  id?: string | null | undefined;
  /**
   * List of parent questions's option IDs
   */
  optionIds?: Array<string> | null | undefined;
  /**
   * Provider's unique identifier
   */
  remoteId?: string | null | undefined;
  /**
   * Provider's list of parent questions's option IDs
   */
  remoteOptionIds?: Array<string> | null | undefined;
};

export enum Question2 {
  True = "true",
  False = "false",
}

export type QuestionRequired = boolean | Question2;

export type Question4 = {};

/**
 * The source value of the questions type.
 */
export type QuestionSourceValue =
  | string
  | number
  | boolean
  | Question4
  | Array<any>;

/**
 * The type of the questions.
 */
export enum QuestionValue {
  ShortText = "short_text",
  LongText = "long_text",
  Attachment = "attachment",
  MultiSelect = "multi_select",
  SingleSelect = "single_select",
  Boolean = "boolean",
  Number = "number",
  Date = "date",
  Video = "video",
  ReferenceCheck = "reference_check",
  Url = "url",
  UnmappedValue = "unmapped_value",
}
/**
 * The type of the questions.
 */
export type QuestionValueOpen = OpenEnum<typeof QuestionValue>;

export type QuestionType = {
  /**
   * The source value of the questions type.
   */
  sourceValue?:
    | string
    | number
    | boolean
    | Question4
    | Array<any>
    | null
    | undefined;
  /**
   * The type of the questions.
   */
  value?: QuestionValueOpen | null | undefined;
};

export type Question = {
  /**
   * Unique identifier
   */
  id?: string | null | undefined;
  multipleChoiceAnswers?:
    | Array<QuestionMultipleChoiceAnswers>
    | null
    | undefined;
  name?: string | null | undefined;
  parentQuestion?: ParentQuestion | null | undefined;
  /**
   * Provider's unique identifier
   */
  remoteId?: string | null | undefined;
  required?: boolean | Question2 | null | undefined;
  text?: string | null | undefined;
  type?: QuestionType | null | undefined;
};

/** @internal */
export const QuestionSchemas4$inboundSchema: z.ZodType<
  QuestionSchemas4,
  z.ZodTypeDef,
  unknown
> = z.object({});

export function questionSchemas4FromJSON(
  jsonString: string,
): SafeParseResult<QuestionSchemas4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QuestionSchemas4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QuestionSchemas4' from JSON`,
  );
}

/** @internal */
export const QuestionSchemasSourceValue$inboundSchema: z.ZodType<
  QuestionSchemasSourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => QuestionSchemas4$inboundSchema),
  z.array(z.any()),
]);

export function questionSchemasSourceValueFromJSON(
  jsonString: string,
): SafeParseResult<QuestionSchemasSourceValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QuestionSchemasSourceValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QuestionSchemasSourceValue' from JSON`,
  );
}

/** @internal */
export const QuestionSchemasValue$inboundSchema: z.ZodType<
  QuestionSchemasValueOpen,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(QuestionSchemasValue);

/** @internal */
export const ConditionType$inboundSchema: z.ZodType<
  ConditionType,
  z.ZodTypeDef,
  unknown
> = z.object({
  source_value: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => QuestionSchemas4$inboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(QuestionSchemasValue$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "source_value": "sourceValue",
  });
});

export function conditionTypeFromJSON(
  jsonString: string,
): SafeParseResult<ConditionType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConditionType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConditionType' from JSON`,
  );
}

/** @internal */
export const ParentQuestion$inboundSchema: z.ZodType<
  ParentQuestion,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition_type: z.nullable(z.lazy(() => ConditionType$inboundSchema))
    .optional(),
  id: z.nullable(z.string()).optional(),
  option_ids: z.nullable(z.array(z.string())).optional(),
  remote_id: z.nullable(z.string()).optional(),
  remote_option_ids: z.nullable(z.array(z.string())).optional(),
}).transform((v) => {
  return remap$(v, {
    "condition_type": "conditionType",
    "option_ids": "optionIds",
    "remote_id": "remoteId",
    "remote_option_ids": "remoteOptionIds",
  });
});

export function parentQuestionFromJSON(
  jsonString: string,
): SafeParseResult<ParentQuestion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParentQuestion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParentQuestion' from JSON`,
  );
}

/** @internal */
export const Question2$inboundSchema: z.ZodNativeEnum<typeof Question2> = z
  .nativeEnum(Question2);

/** @internal */
export const QuestionRequired$inboundSchema: z.ZodType<
  QuestionRequired,
  z.ZodTypeDef,
  unknown
> = z.union([z.boolean(), Question2$inboundSchema]);

export function questionRequiredFromJSON(
  jsonString: string,
): SafeParseResult<QuestionRequired, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QuestionRequired$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QuestionRequired' from JSON`,
  );
}

/** @internal */
export const Question4$inboundSchema: z.ZodType<
  Question4,
  z.ZodTypeDef,
  unknown
> = z.object({});

export function question4FromJSON(
  jsonString: string,
): SafeParseResult<Question4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Question4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Question4' from JSON`,
  );
}

/** @internal */
export const QuestionSourceValue$inboundSchema: z.ZodType<
  QuestionSourceValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
  z.lazy(() => Question4$inboundSchema),
  z.array(z.any()),
]);

export function questionSourceValueFromJSON(
  jsonString: string,
): SafeParseResult<QuestionSourceValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QuestionSourceValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QuestionSourceValue' from JSON`,
  );
}

/** @internal */
export const QuestionValue$inboundSchema: z.ZodType<
  QuestionValueOpen,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(QuestionValue);

/** @internal */
export const QuestionType$inboundSchema: z.ZodType<
  QuestionType,
  z.ZodTypeDef,
  unknown
> = z.object({
  source_value: z.nullable(
    z.union([
      z.string(),
      z.number(),
      z.boolean(),
      z.lazy(() => Question4$inboundSchema),
      z.array(z.any()),
    ]),
  ).optional(),
  value: z.nullable(QuestionValue$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "source_value": "sourceValue",
  });
});

export function questionTypeFromJSON(
  jsonString: string,
): SafeParseResult<QuestionType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QuestionType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QuestionType' from JSON`,
  );
}

/** @internal */
export const Question$inboundSchema: z.ZodType<
  Question,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.string()).optional(),
  multiple_choice_answers: z.nullable(
    z.array(QuestionMultipleChoiceAnswers$inboundSchema),
  ).optional(),
  name: z.nullable(z.string()).optional(),
  parent_question: z.nullable(z.lazy(() => ParentQuestion$inboundSchema))
    .optional(),
  remote_id: z.nullable(z.string()).optional(),
  required: z.nullable(z.union([z.boolean(), Question2$inboundSchema]))
    .optional(),
  text: z.nullable(z.string()).optional(),
  type: z.nullable(z.lazy(() => QuestionType$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "multiple_choice_answers": "multipleChoiceAnswers",
    "parent_question": "parentQuestion",
    "remote_id": "remoteId",
  });
});

export function questionFromJSON(
  jsonString: string,
): SafeParseResult<Question, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Question$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Question' from JSON`,
  );
}
